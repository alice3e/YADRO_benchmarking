**Тест `cpu` в sysbench**

Основная задача теста `cpu` — измерить "сырую" вычислительную мощность процессора(ов) путем выполнения математически интенсивной задачи, которая минимально зависит от других подсистем (памяти, диска).

**Как работает тест `cpu`?**

По умолчанию `sysbench cpu` выполняет следующую операцию в цикле:

1. Берет число.
2. Проверяет, является ли оно простым, путем перебора делителей до квадратного корня из этого числа.
3. Повторяет это для чисел до определенного предела (`--cpu-max-prime`).

Каждая успешная проверка простого числа до заданного лимита считается одним **"событием"** (event) в терминологии `sysbench`.

**Почему проверка простых чисел?**

* **CPU-bound:** Эта задача требует в основном вычислительных ресурсов процессора (целочисленная арифметика, циклы, ветвления).
* **Минимальная зависимость от памяти:** Хотя данные находятся в памяти, объем этих данных и интенсивность обращений к памяти относительно невелики по сравнению с нагрузкой на вычислительные ядра. Пропускная способность памяти редко становится узким местом для этого теста.
* **Минимальная зависимость от I/O:** Тест вообще не использует дисковый ввод/вывод.
* **Масштабируемость:** Задачу легко распараллелить на несколько потоков (ядер).

**Основные параметры (опции) для теста `cpu`:**

* `--threads=N`: **Самый важный параметр для CPU-тестирования.** Задает количество рабочих потоков.
  * `--threads=1`: Тестирует производительность одного ядра процессора. Полезно для сравнения "однопоточной" производительности разных CPU.
  * `--threads=N` (где N > 1): Тестирует производительность нескольких ядер одновременно. Обычно N устанавливают равным количеству логических ядер в системе (например, с учетом Hyper-Threading/SMT) или физических ядер, чтобы оценить максимальную параллельную производительность и масштабируемость.
* `--cpu-max-prime=N`: Максимальное число, до которого будут искаться простые числа в рамках одного "события".
  * Увеличение этого значения делает каждое событие более длительным и сложным.
  * Уменьшение делает каждое событие короче, но их будет больше за то же время.
  * Значение по умолчанию (часто 10000 или 20000 в новых версиях) обычно является хорошей отправной точкой. Изменять его стоит, если вы хотите сравнить результаты с другими тестами, где использовалось иное значение, или если хотите специфически нагрузить CPU очень короткими или очень длинными задачами. **Для сравнительных тестов важно использовать одно и то же значение `--cpu-max-prime`.**
* `--time=N`: **Обязательный параметр (или `--events`).** Задает продолжительность теста в секундах. Это наиболее распространенный способ контролировать длительность теста CPU.
* `--events=N`: **Обязательный параметр (или `--time`).** Задает общее количество событий (проверок простых чисел), которое должно быть выполнено всеми потоками суммарно. Тест завершится после выполнения этого количества событий.
* `--report-interval=N`: Выводить промежуточные результаты каждые N секунд. Полезно для наблюдения за стабильностью производительности во время длительных тестов (например, для выявления троттлинга из-за перегрева).
* `--percentile=N`: Рассчитывать и выводить N-й перцентиль времени выполнения одного события (по умолчанию 95). Показывает стабильность времени выполнения задачи.

**Как проводить тестирование CPU с помощью sysbench:**

1. **Определите количество ядер:** Узнайте, сколько логических процессоров доступно вашей системе.

   ```bash
   grep -c ^processor /proc/cpuinfo
   # или
   nproc
   ```
2. **Тест производительности одного ядра:**

   ```bash
   # Запустить тест на 60 секунд в одном потоке
   sysbench cpu --threads=1 --time=60 run
   ```

   * Запомните или запишите значение `events per second`.
3. **Тест производительности всех ядер (масштабируемость):**

   ```bash
   # Заменить <N_CORES> на количество логических ядер из шага 1
   N_CORES=$(nproc)
   sysbench cpu --threads=$N_CORES --time=60 run
   ```

   * Запомните или запишите значение `events per second`.
   * **Анализ масштабируемости:** Сравните результат многопоточного теста с однопоточным. В идеальном мире производительность в `N_CORES` потоков должна быть в `N_CORES` раз выше, чем в 1 поток. На практике она будет ниже из-за накладных расходов на синхронизацию, возможной борьбы за кэш, ограничений Turbo Boost для всех ядер, Hyper-Threading/SMT (логические ядра обычно менее производительны, чем физические) и потенциального троттлинга. Хорошая масштабируемость означает, что многопоточный результат значительно (например, в >80% от идеального) превышает однопоточный, умноженный на количество *физических* ядер.
4. **Тест на стабильность (выявление троттлинга):**
   Запустите тест на длительное время (например, 5-10 минут) с максимальным количеством потоков и включите промежуточные отчеты.

   ```bash
   N_CORES=$(nproc)
   # Запуск на 300 секунд (5 минут) с отчетом каждые 10 секунд
   sysbench cpu --threads=$N_CORES --time=300 --report-interval=10 run
   ```

   * Следите за `events per second` в промежуточных отчетах. Если это значение со временем **значительно снижается**, это может указывать на **термический троттлинг** (процессор снижает частоту из-за перегрева).

**Интерпретация результатов теста `cpu`:**

* `CPU speed:`
  * `events per second:` **Ключевой показатель производительности.** Чем выше это значение, тем быстрее процессор выполняет вычисления в данном тесте. Используйте это значение для сравнения разных процессоров или конфигураций.
* `General statistics:`
  * `total time:` Фактическое время выполнения теста.
  * `total number of events:` Общее количество выполненных проверок простых чисел.
* `Latency (ms):` Время, затраченное на выполнение одного события (одной полной проверки до `--cpu-max-prime`).
  * `min`, `avg`, `max`, `NN.NNth percentile`: Показывают распределение времени выполнения событий. Низкие значения и малая разница между `avg` и перцентилем указывают на стабильную производительность. Высокий `max` или перцентиль по сравнению с `avg` может указывать на прерывания со стороны ОС или другие факторы, вызывающие задержки.
* `Threads fairness:`
  * `events (avg/stddev)`: Среднее количество событий на поток и стандартное отклонение. Низкое отклонение (`stddev`) означает, что нагрузка была распределена между потоками равномерно.
  * `execution time (avg/stddev)`: Среднее время работы каждого потока и стандартное отклонение. Низкое отклонение означает, что все потоки работали примерно одинаковое время. Высокое отклонение может указывать на проблемы с планировщиком ОС, неравномерную производительность ядер (редко) или то, что один поток "застрял".

**Мониторинг во время теста CPU:**

Хотя `sysbench` дает итоговые цифры, полезно наблюдать за системой *во время* теста:

1. **`top` / `htop`:**
   * Убедитесь, что загрузка CPU (`%us` - user space) близка к 100% * количество потоков / общее количество ядер. Например, при 4 потоках на 8-ядерной системе ожидается около 50% общей загрузки CPU, но при этом 4 ядра должны быть загружены на 100%. `htop` отлично визуализирует загрузку отдельных ядер.
   * Следите, чтобы не было высокой загрузки `%sy` (system/kernel) или `%wa` (I/O wait) — это означало бы, что тест не чисто процессорный или есть проблемы в системе.
   * `htop` часто показывает тактовую частоту CPU и температуру. Наблюдайте, не падает ли частота и не растет ли температура слишком сильно во время длительных тестов.
2. **`vmstat 1`:**
   * Колонка `us` должна показывать высокие значения.
   * Колонки `sy` и `wa` должны быть низкими.
   * Колонка `r` (run queue) должна примерно соответствовать количеству запущенных потоков `sysbench`, если нет других ресурсоемких процессов.
3. **Инструменты мониторинга частоты и температуры:**
   * `turbostat` (часто требует `msr-tools` и запуска от root): Детальная информация о частотах, состояниях C-state/P-state, температуре ядер.
   * `sensors` (из пакета `lm-sensors`): Показывает температуру CPU и других компонентов.
   * `cpupower frequency-info` / `cpupower monitor`: Информация о текущей частоте и политиках управления частотой.

**Резюме по применению sysbench для CPU:**

* Используйте тест `sysbench cpu`.
* Ключевые опции: `--threads`, `--time` (или `--events`), `--cpu-max-prime`.
* Проводите однопоточные и многопоточные тесты для оценки как пиковой производительности одного ядра, так и общей производительности и масштабируемости.
* Запускайте длительные тесты с `--report-interval` для проверки стабильности и выявления троттлинга.
* Основной показатель для сравнения — `events per second`.
* Используйте `top`/`htop`, `vmstat` и другие утилиты для мониторинга загрузки CPU, частоты и температуры во время теста.
* Помните, что это синтетический тест, измеряющий в основном целочисленную производительность. Он хорошо подходит для относительных сравнений, но не всегда напрямую отражает производительность в реальных приложениях со сложным профилем нагрузки.
